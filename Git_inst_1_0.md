![logo](git.png)
## *Основы*   
**Git** — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус). Изначально Git был создан Линусом Торвальдсом при разработке ядра Linux. Однако инструмент так понравился разработчикам, что в последствии, он получил широкое распространение и его стали использовать в других проектах. С его помощью вы можете сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению. Этот процесс называется контролем версий.

**Для чего он нужен?** 

 Ну во-первых, чтобы отследить изменения, произошедшие с проектом, со временем. Проще говоря, мы можем посмотреть как менялись файлы программы, на всех этапах разработки и при необходимости вернуться назад и что-то отредактировать. Часто бывают ситуации, когда, во вполне себе работающий код, вам нужно внести определенные правки или улучшить какой-то функционал, по желанию заказчика. Однако после внедрения нововведений, вы с ужасом понимаете, что все сломалось. У вас начинается судорожно дергаться глаз, а в воздухе повисает немой вопрос: “Что делать?” Без системы контроля версий, вам надо было бы долго напряженно просматривать код, чтобы понять как было до того, как все перестало работать. С Гитом же, все что нужно сделать - это откатиться на коммит назад.

Во-вторых он чрезвычайно полезен при одновременной работе нескольких специалистов, над одним проектом. Без Гита случится коллапс, когда разработчики, скопировав весь код из главной папки и сделав с ним задуманное, попытаются одновременно вернуть весь код обратно.
Git является распределенным, то есть не зависит от одного центрального сервера, на котором хранятся файлы. Вместо этого он работает полностью локально, сохраняя данные в директориях на жестком диске, которые называются репозиторием. Тем не менее, вы можете хранить копию репозитория онлайн, это сильно облегчает работу над одним проектом для нескольких людей. Для этого используются сайты вроде github и bitbucket.


# *Инструкция по настройке  Git!!!*

## 1. Проверка наличия установленного Git.
В терминале выполнить команду 
``` 
git version 

```

Если Git установлен и настроен правильно, появится сообщение с версией программы.
Иначе будет сообщение об ошибке.

## 2. Установка Git.
Загружаем последнюю версию Git с сайта: https://git-scm.com/downloads и устанавливаем с настройками по умолчанию.

## 3. Настройка Git.
При первом использовании Git необходимо представиться.
Для этого нужно ввести в терминале 2 команды:
```
git config --global user.name «Ваше имя английскими буквами»

git config --global user.email ваша почта@example.com
```
Теперь каждое наше действие будет отмечено именем и почтой. Таким образом, пользователи всегда будут в курсе, кто отвечает за какие изменения — это вносит порядок.


# *По выполнению всех условий можем приступать к работе с Git! :)*

Git хранит весь пакет конфигураций в файле .gitconfig, находящемся в вашем локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг –global. Если вы этого не сделаете, они будут распространяться только на текущий репозиторий.
Для того, чтобы посмотреть все настройки системы, используйте команду:
```
git config --list
```
*Если вы не до конца настроили систему для работы, в начале своего пути - не беда. Git всегда подскажет разработчику, если тот запутался, например:*

-  Команда **git --help** - выводит общую документацию по git

-  Если введем **git log --help** - он предоставит нам документацию по какой-то определенной команде (в данном случае это - log)

-  Если вы вдруг сделали опечатку - система подскажет вам нужную команду

- После выполнения любой команды - отчитается о том, что вы натворили

- Также Git прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше

*Тут стоит отметить, что подсказывать система будет на английском, но не волнуйтесь, со временем вы изучите несложный алгоритм ее работы и будете разговаривать с ней на одном языке.*


# *Создание нового репозитория*
Как мы отметили ранее, git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно:
1. Создайте на рабочем столе папку под названием Git
2. В приложение создаем фаил с разрешением **.md**
3. Включаем автосахронение (Файл -> Автосахронение)
4. Открываем терминал. Выбираем терминал (Git Bash)
5. Выполняем команду **git init**

Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.

# Определение состояния
 **git status** — это одна из важнейших команд, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. 

 # Подготовка файлов
В Git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой
```
git add (имя файла)
```

# Фиксация изменений и создание коммита
 Для сохранения изменений, их необходимо закоммитить. Для этого необходимао ввести команду **git commit -m 'Комментарий'**. Но сначала, мы должны обозначить эти файлы для Git, при помощи команды **git add (имя файла)**, добавляющей (или подготавливающей) их к коммиту. 
 ```
 1. git add (имя файла)

 2. git commit -m 'Комментарий'
 ```
 Флажок **-m** задаст *commit message* - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»

# Просмотр коммитов
Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:
```
git log
```
В ней содержиться вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды *git show* :
```
git show hash_commit
```
Ну а если вдруг нам нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию:
```
git commit --amend -m 'Новый комментарий'
```
В данном случае сообщение последнего коммита перезапишется. **Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.**

# Синтаксис языка Markdown
```
- Заголовок – выделение заголовков. Количество символов “#” задаёт уровень заголовка
(поддерживается 6 уровней).
-  = или - – подчёркиванием этими символами (не менее 3 подряд) выделяют заголовки
первого (“=”) и второго (“-”) уровней.
-  ** Полужирное начертание** или __ Полужирное начертание__
-  *Курсивное начертание* или _Курсивное начертание_
-  ***Полужирное курсивное начертание***
-  ~~Зачёркнутый текст~~
-  * Строка – ненумерованные списки, символ “*” в начале строки
-  1, 2, 3 … – нумерованные списки
```

## Добавление изображений и игнорирование в Git

Для того чтобы добавить картинку в Git необходимо:
1. Добавить нужное изображение в корневую папку.
2. Создать файл ```(.gitignore)``` и внести в него необходимые расширения: .png, .jpg и т.д.
3. В том мете где необходимо вставить изображение, вводим команду:
```
![logo](имя изображения)

Пример: ![logo](Vetki.jpg)
```
## Игнорирование файлов
Для того чтобы исключить из отслеживания репозитории определенного файла или папки, необходимо создать файл **```.gitignore ```**  и записать в него их названия или шаблоны таких файлов и папок.


## Ветки в Git и как они работают:
![logo](Vetki.jpg)
Ветка Git это простой перемещаемый указатель на один из коммитов, обычно последний в цепочке коммитов. По умолчанию имя основной ветки в Git -``` *master*.```

## Создание веток в Git.
Создать ветку можно командой:  
``` 
git branch (имя ветки)
``` 

Так же для создание новой ветки и автоматического перехода в нее, используется команда:
```
git switch -c (имя ветки)
```
В результате создается новый указатель на текущий момент.

Спиоск веток можно посмотреть командой :
```
git branch
```
Текущая ветка отображается звездочкой ```( *master )```

Для перехода между ветвями используйте команду :
```
git checkout (имя ветки)
```

## Слияние веток и разрешение конфликтов

Для слияния выбранной ветки с текущей нужно выполнить команду:
``` 
git merge (имя ветки) 
```
## Конфликты слияния в Git
Системы контроля версий предназначены для управления дополнениями, вносимыми в проект множеством распределенных авторов (обычно разработчиков). Иногда один и тот же контент могут редактировать сразу несколько разработчиков. Если разработчик A попытается изменить код, который редактирует разработчик B, может произойти конфликт. Для предотвращения конфликтов разработчики работают в отдельных изолированных ветках. Основная задача команды git merge заключается в слиянии отдельных веток и разрешении любых конфликтующих правок.

Общие сведения о конфликтах слияния
Слияние и конфликты являются неотъемлемой частью работы с Git. В других инструментах управления версиями, например SVN, работа с конфликтами может быть дорогой и времязатратной. Git позволяет выполнять слияния очень просто. В большинстве случаев Git самостоятельно решает, как автоматически интегрировать новые изменения.

Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.


Git прерывает работу в самом начале слияния
Выполнение команды слияния прерывается в самом начале, если Git обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. Git не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд git stash, git checkout, git commit или git reset. 
если была изменена одна и та же часть файла в обеих ветках , то может возникнуть конфликт, который потребует участие пользователя. VScode покажет различия в ветках и предложет варианты разрешения конфликта.

## Удаление веток

Для того чтобы удалить не нужную ветку необходимо выполнить команду:
```
git branch -d (имя ветки)
```
Обратите внимание на то, что ветка, которую вы удаляете, не должна быть вашей текущей веткой, в которой вы работаете, иначе отобразится ошибка вида:```
error: Cannot delete branch ’mybranch’ checked out at ’/path/to```
Поэтому, если вам нужно удалить текущую ветку, то сначала нужно переключиться на какую-либо другую ветку, а только потом выполнять удаление.

Если вдруг возникает ошибка: ``` The branch ’mybranch’ is not fully merged. If you are sure you want to delete it``` и вы по прежнему хотите удалить ветку, то для принудительного удаления ветки можно воспользоваться опцией -D:

# Работа с удалённым репозиторием
Коммит, созданный нами, хранится в репозитарии, привязанном к конкретной папке на нашем компьютере, т.е. является локальным. Это полезно, если мы работаем над проектом самостоятельно. Однако в большинстве случаев возникает необходимость обеспечить доступ к результатам работы или доставить код на сервер, где он будет выполняться.
Как подключиться к удаленному репозитарию.

1. __Для загрузки данных в удаленный репозитарию сначала нужно к нему подключиться.__ 

В нашем примере мы используем адрес https://github.com/tutorialzine/awesome-project, однако пользователь может создать собственный удаленный репозитарий на GitHub, BitBucket или другом подобном сервисе. Это занимает некоторое время, однако в дальнейшем полностью себя оправдывает, тем более, что подобные службы имеют пошаговые инструкции для правильно выполнения нужных действий.



Для того, чтобы связать созданный нами локальный репозитарий с удаленным, выполним такую команду:
```
git remote add origin https://github.com/tutorialzine/awesome-project.git
```
Иногда бывает так, что проект имеет несколько удаленных репозитариев – в таком случае каждому из них присваивается собственное имя. Главный репозитарий принято называть origin.

2. __Как отправить изменения в удаленный репозитарий?__


Теперь, когда у нас в локальном репозитарии создан коммит и мы подключились к удаленному, можем отправить его на сервер. Мы это будем делать каждый раз, когда хотим обновить данные в удаленном репозитарии.



Отправка коммита осуществляется с помощью команды push, которая имеет два параметра - имя удаленного репозитория (в нашем случае origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев). Для этого выполняем команду:
```
git push origin master
```

Если мы все сделали правильно, то отправленный файл на удаленном сервере мы можем увидеть с помощью браузера. Важный момент – некоторые сервисы для отправки изменений могут требовать дополнительной аутентификации.


3. __Как клонировать удаленный репозитарий?__

Если у других пользователей возникла необходимость клонировать удаленный репозитарий, они могут получить полностью работоспособную копию при помощи команды clone:
```
git clone https://github.com/tutorialzine/awesome-project.git
```

GitHub автоматически создаст новый локальный репозитарий в виде удаленного на собственном сервере.


4. __Как запросить изменения с удаленного репозитария?__


В случае, если другим пользователям нет необходимости делать клон удаленного репозитария, а нужно просто получить информацию об изменениях, это можно сделать с помощью команды pull:
```
git pull origin master
```


Она скачивает новые изменения. Так как мы ничего нового не вносили с тех пор, как клонировали проект, изменений, доступных к скачиванию, нет.

## Pull request

 Pull request — предложение изменения кода в чужом репозитории.
Вы делаете форк чужого репозитория (который иногда и сам может быть форком) → производите изменения в своём форке → посредством pull request предлагаете изменения владельцам репозитория, чей форк Вы сделали. 
1. __С чего начать?__

А для начала этот самый репозиторий нужно форкнуть (fork — вилка, ответвление). Разберём это нехитрое действо на примере веб-сервиса для хостинга IT-проектов, название которому GitHub. Разумеется, кроме GitHub есть и другие: BitBucket, например. Выбирать по вкусу.
Заходим на страницу интересующего проекта, жмём кнопку Fork, ищем на своей странице URL для клонирования.
В терминале выполняем команду:
```
git clone (вставляем адрес с Github)
```
Отлично. Уже можно вносить свои изменения в код проекта.

Тот репозиторий, что теперь лежит на вашем жёстком диске, независим от основного. В нём отслеживаются только ваши наработки. Но как следить за изменениями, происходящими в первоисточнике, откуда вы «стянули» репозиторий? Добавить удаленный репозиторий в отслеживаемые. Например, так:
```
git remote -v
git remote add upstream (адрес с Github)
```
После добавления upstream в отслеживаемые, наберите команду __git remote -v__ ещё раз, вы должны увидеть произошедшие изменения.

Давайте посмотрим как сливать изменения из оригинального репозитория к себе в случае, если разработка в нём ушла вперёд пока вы сосредоточенно писали коммиты:
```
git pull upstream master
```

У нас есть основной репозиторий с веткой master и недавно добавленный нами — с upstream. Команда, данная выше, забирает всё новое из ветки upstream и сливает изменения в master. Так, мы всегда можем получить последние наработки.

Вы можете также воспользоваться другой командой — __fetch__ вместо указанной __pull__. В таком случае git заберет изменения с удаленного репозитория, но не будет пытаться слить их с вашей текущей веткой автоматически.


```
git fetch upstream
git merge upstream/master
```
Допустим, мы написали, что хотели и сделали коммит. Забираем изменения (но не сливаем их, fetch) из upstream. Затем вручную сливаем изменения из удалённой ветки upstream/master к себе (merge), разрешаем конфликты (если есть) и снова делаем коммит.

Если репозиторий огромен, а забирать его весь не хочется, клонируем только нужную ветку:
```
git clone -b real_branch --single-branch (адрес с Github)
```

Вносите в код свои изменения, а когда закончите просто переключитесь обратно к своей основной ветке. Вы можете отправить pull request, выбрав ветку new_branch или же прежде слить изменения из неё в основную ветку разработки. Рассмотрим это подробнее:
```
git checkout master
git merge new_branch 
```
Если нужно отправить в свой удалённый репозиторий вновь созданную ветку (не сливать её с master), делаем следующее:

```
 git push master new_branch
 
 ```


## Отправляем изменения
Добрались таки до ответа на поставленный вопрос: что такое pull request, зачем оно нужно и как его достичь. Как предложить владельцу репозитория свои изменения?

Для этого зайдите в свой аккаунт, выбирайте репозиторий владельца и ищите небольшую зелёную кнопку.
Перед тем как сделать запрос вы имеете возможность добавить комментарий, просмотреть то, какие файлы будут изменены, какие коммиты добавлены. В верхнем углу окна добавления запроса обратите внимание откуда куда и что вы сливаете. Если необходимо слить основные ветки выбор падёт на репозиторий username:master, если отдельную ветку (вспоминаем branch) — так и указывайте её.


# Повторение изученного и команды которые необходимо знать :)
 1.  dit init - создает новый репозиторий Git. С ее помощью можно преобразовать существующий файл без управления версиями в репозиторий Git или инициализировать новый пустой репозиторий.         Большинство остальных команд Git невозможно использовать без инициализации репозитория, поэтому данная команда обычно выполняется первой в рамках нового файла. 
 2.  dit status - отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются Git. Информация об истории коммитов файла не отображается при выводе данных о состоянии.
 3.  git add - это первая команда в цепочке операций, предписывающей Git «сохранить» снимок текущего состояния файла в истории коммитов. Когда git add используется как отдельная команда, она переносит ожидающие изменения из рабочего каталога в раздел проиндексированных файлов.
 4.  git commit -m - команда для записи индексированных изменений в репозиторий Git. Флаг -m прописывает комментарий к файлу на данный момент.
 5.  git log - показывает всю историю коммитов и позволяет быстро просмотреть все изменения, сделанные с файлом. 
 6. git diff - это функция cравнения, анализирующая два входных набора данных и отображающая различия между ними.
 7.  git checkout -  подразумевают переключение между различными версиями целевого объекта. Команда git checkout работает с тремя различными объектами: файлами, коммитами и ветками. 
 8.  git checkout master - возвращает к актуальной версии файла и продолжает работу в ней.
    
 9.  git commit -a 'Новый комментарий' -  совершит коммит, автоматически индексируя изменения в файлах
проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов будет учтено.
 10. git branch (имя ветки) - просто перечислит существующие ветки, отметив активную
 11. git branch -d (имя ветки) - удалит ветку, если та была залита (merged) с разрешением возможных конфликтов в текущую.
 12. git merge (имя ветки) -попробует объединить текующую ветку и ветку (имя ветки).
 13. git pull - используется для извлечения и загрузки содержимого из удаленного репозитория и немедленного обновления локального репозитория этим содержимым
 14. git push - используется для выгрузки содержимого локального репозитория в удаленный репозиторий. Она позволяет передать коммиты из локального репозитория в удаленный. Эта команда симметрична команде git fetch: при извлечении с помощью fetch коммиты импортируются в локальные ветки, а при публикации с помощью push коммиты экспортируются в удаленные ветки.
 15. git clone - команда клонирования репозитория - используется для первоначального копирования репозитория, т.е. для создания копии на вашей машине, когда у вас вообще ничего нет - скачает всю информацию.
 16. git remote - это интерфейс для управления списком записей об удаленных подключениях, которые хранятся в файле /.git/config репозитория.

